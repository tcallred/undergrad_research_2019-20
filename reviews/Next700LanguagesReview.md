# The Next 700 Languages Review

This is being one of the first academic papers I have ever seriously read, I found that there were many things that were hard to understand simply because of a lack of contextual knowledge. This paper was written in the 1960's, when many aspects of programming languages that we consider ubiquitous and given were being thought-up and discussed. While the bulk of this paper was difficult to read and understand (particularly the details of his language specifications) I eventually understood the overall purpose and meaning of the paper and why it still matters today.

## My understanding
I understood eventually (according to my limited contextual knowledge) that Landin's purpose in writing this paper was twofold: to layout the high-level specifications for a *family* of languages with no particulars about underlying implementation, and to layout the specifications of a language that is both declarative and functional. 

In an era where procedural languages was the norm and programming as an art was being defined by the rudementary implementations (namely the Von-Neumann machine and the byte-code that controls it) Landin proposes a high level language called ISWIM that resembles mathematics. Instead of describing the *procedure* akin to the bytecode being loaded into the processor one at a time, this language declares *functional truths* that are irrefutable and who's relationships lead to conclusions about the behavior of the program. Indeed the name "If you See What I Mean" suggests that the reader of the code can come to conclusions about the intentions of the original programmer quickly and easily. Instead of working about the effects of each *statement*, the reader simply reads the axiomatic *expressions*. 

This language, while it takes after mathematics, reminded me of lambda calculus as it is a high level description of axiomatic facts that lead to an irrefutable conclusion rather that a description of a procedural machine. That thinking naturally leads to LISP, which was fully concieved at this time period, is the spiritual child of lambda calculus, and is mentioned in this very paper. Unfortunately, the comparison Landin makes between his new language and LISP uses language and ideas that did not make much sense to me. I would like to review that further. The question being: "What does ISWIM bring to the table that LISP did not?". What I do understand is that ISWIM is syntactically more similar to mathematics than to lambda calculus, is more abstract, and is problem-space agnostic.

The purpose of the paper is also made clear in the conclusion. Landin asks the reader to reflect on these key questions: "Do the idiosyncracies [of a language] reflect basic logical properties of the situations that are being catered for? Or are they accidents of history and personal background that may be obscuring fruitful developments?" It seems that his intention was for people to take this abstract specification and apply it and manipulate it for their own problem-specific domain. The thought being that a good language has more essential parts to to program and less incidental parts (which are all too prevalent in low-level languages such as C++, where much of what you write is simply to 'make it work right' than to express your intention). 

The general idea of removing "incidental" parts of a language are also seen in popular scripting languages such as Python, where low-level problems are abstracted away and the programmer is encouraged to express their intention in few readable lines of code. But, the influence of ISWIM is seen most clearly in the ML-family of languages as well as Haskell and Elm. These languages use clear axiomatic expressions, benefit from pure functional programming, and fulfill what Landin mentions in the conclusion which is providing an "alternative to explicit sequencing". 

What strikes me is that Landin does not seek to invent a "silver bullet" language to end all programming languages. Rather, he describes a family of languages that share a common abstract syntax. He doesn't specify how to implement a concrete instance of this family but leaves the door open for others to apply his idea to their own problem space. This philosophy is seen clearly in Evan Czaplicki and his Elm language. Czaplicki designed Elm to solve a specific problem: functional programming in front-end development. The language is tailored for that purpose and he has mentioned often that he does not intend to target other problem areas.

To me, Landin's approach solves two competing issues: the desire to have a lingua-franca among developers and a need to have programs that have less incidental parts. The key here is to have a generalized abstract family of languages to achieve standardization but to have specific implementations catered to the domain. 