# End of semester review
Generally speaking, I feel like I learned a lot of useful things about programming languages. Much of what we studied broadened my vision of what is currently possible in programming language design and what has yet to be done. Unfortunately, I spent the semester with the thought in mind that this would continue into the next semester. I don't know what put that in my mind in the first place or why I never confirmed it, but had I known that from the start I might have tried to get more out of it. Alas, it was my own ignorance and I feel like I have directions to go. 

## Reading the literature
I would say that for the most part, reading the papers that were assigned to me were understandable and enjoyable. There were plenty of times where I felt like I did not have the information to participate in the conversation being had or like it was just really difficult to understand. I feel like one of the main themes I picked up from my reading was the power of constraints in a language. By constraining the user, you can make far more guarantees about the expressiveness and correctness of a program. For example, we read about linear typing. With that, values can be freed after their use because they are only used once in the function. You can also make guarantees about concurrency. Another constraint that adds guarantees was 2nd class functions which limit the possible unwanted side effects of capturing state in a closure. 
While I didn't get to writing my review about it, I enjoyed my study of the racket philosophy and language-oriented programming. In a world where "general purpose" has been the accepted dogma, I think there is great power to be utilized by treating language as an extra layer of abstraction. By creating small domain-specific languages, you create code that expresses the intent of the user more clearly and makes it harder to write code that can fail. Also, specific languages have strengths in different areas, and one can leverage the strengths of languages for specific tasks. 
In Lambda The Ultimate, I learned about how scheme, with the syntax of lisp and only the most fundamentally necessary underlying implementations, can be used extremely well to make code in multiple paradigms. 
I feel like my ability to navigate the literature in this area has been enhanced, and I hope to be able to keep improving so that might be able to contribute something of worth later in my career. 

## Scheme compiler and MuKanren
I thoroughly enjoyed writing the scheme compiler, at least up to the point I was able to, and making the mukanren implementation work after staring at that code for so long was quite gratifying. Translating from scheme to Haskell was very challenging mainly because I had a hard time reasoning about scheme code but it taught me what the true pleasure and pain points of writing in Haskell versus scheme were. For the compiler it was nice to have algebraic data types to represent my AST. Haskell gives great tools for processing through ADTs and I felt like I was making a more robust and sound implementation than the scheme version. For the MuKanren, however, ADTs got in the way of getting to a working solution for both mukanren itself and the type checker. I realize the use and power of a dynamically typed language particularly for whipping up a working library, particularly something as small and clever as mukanren. Haskell's types help out immensely for understanding code and keeping a large code-base sound, but its rigidity got in the way on this project. 
I put effort into the MuKanren project that was disproportionate to how small and simple MuKanren is in the paper. I feel like I had to struggle to understand it, but because of that struggle I feel quite confident that I could apply its concepts to other applications. I know that Clojure includes miniKanren in its logic.core library and many langues also have their own implementations. I particularly like the fact that the language is embedded because it means that in nearly any kind of application, a programmer can use it to have the program make logical decisions in a way that is readable and relieves mental effort. I could see it being used in machine-learning applications embedded in websites, desktop apps, or robotics. 

## Some notes for you specifically 
Thank you very much for taking me on as your student for this semester. I was legitimately excited to learn and try the things that we talked about. One note I have is that often you would try to explain something or have me read something that I felt I did not have enough preliminary knowledge for. When you taught new concepts to me, they were very clear and well explained as long as you knew how much I already knew about the topic. 
It would have been nice to learn more about racket from you, considering that seems to be your area of expertise, but I respected greatly the fact that you focused the semester on what I had shown specific interest in. 
Other than that, we might have been able to get more out of the semester had it been a little more organized, but I am not complaining because I genuinely enjoyed the sporadic and exploratory nature of this research class. 

## Going forward
I hope that I can use my newfound knowledge to contribute something to the world of PL. I have strong belief that good languages can make happy and satisfied developers and the pursuit of good language design is a noble goal. Some things that I would like to do in the future.
1. Work in a corporate environment in functional language
2. Become more fluent in racket and LOP, so that I can use it to iterate on ideas
3. Bridge the gap between high level convenience and low level performance 
4. Work on open source languages in development. One such language I have started to get involved in is Clio. Understanding parsing and AST has been so satisfying when I look at their source code. 
5. Create programming languages that I like 

Thank you very much, once again. I hope to stay in contact with you in the future. 

~Taylor Allred